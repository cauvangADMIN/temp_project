<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bakugou UI Layout</title>
  <link rel="stylesheet" href="assets/css/index.css">
</head>
<body>
  <section class="hero-section">
    <div class="mini-bg">
      <div class="title-text">Goddess of Victory: Nikke</div>
      <div class="character_name" id="character_name">Character Name</div>
      <div class="carousel" id="carousel"></div>

      <button class="nav-btn prev-btn" onclick="prevCharacter()">⟨</button>
      <button class="nav-btn next-btn" onclick="nextCharacter()">⟩</button>
      <button class="send-nude-btn" id="send-nude-btn">Send Nude</button>
    </div>

    <div class="sidebar">
      <a href="index.html">Home</a>
      <a href="#" id="about-toggle">About</a>
      <div class="about-popover" id="about-popover">
        <div class="close-popover" id="close-about-popover">✕</div>
        <div class="about-content">
          This website is <span class="highlight-green"><strong>completely free</strong></span> for exploring and capturing your own wallpapers using <span class="highlight-green"><strong>Photo Mode</strong></span>. However, it does <span class="highlight-red"><strong>include ads to help us maintain the site</strong></span>. We hope you enjoy your experience here, and kindly keep things respectful.
        </div>
      </div>
      <a href="#" id="photo-mode-toggle">Photo Mode</a>
      <a href="#" id="theme-toggle">Change Theme</a>
      <div class="theme-popover" id="theme-popover">
        <div class="theme-popover-title">Choose a color</div>
        <div class="close-popover" id="close-popover">✕</div>
      </div>
      <div class="photo-mode-popover" id="photo-mode-popover">
        <div class="photo-mode-popover-title">Photo Mode</div>
        <div class="close-popover" id="close-photo-popover">✕</div>
        <div class="photo-mode-options">
          <div class="photo-mode-option" data-mode="off">OFF</div>
          <div class="photo-mode-option" data-mode="on">ON</div>
        </div>
      </div>
    </div>

    <div class="top-right">Watched characters: 0</div>
  </section>

  <script>
    const images = [
      "assets/images/ecchi-1-removebg-preview.png",
      "assets/images/ecchi-2-removebg-preview.png",
      "assets/images/ecchi-3-removebg-preview.png",
      "assets/images/ecchi-4-removebg-preview.png",
      "assets/images/ecchi-5-removebg-preview.png",
      "assets/images/ecchi-6-removebg-preview.png",
      "assets/images/ecchi-7-removebg-preview.png"
    ];

    // Character names corresponding to each image
    const characterNames = [
      "Scarlet",
      "Rapunzel",
      "Neon Blue",
      "Privaty",
      "Scarlet",
      "Helm",
      "Modernia"
    ];

    // Create nude versions of the images by adding _nude before the extension
    const nudeImages = images.map(img => {
      const dotIndex = img.lastIndexOf('.');
      return img.substring(0, dotIndex) + '_nude' + img.substring(dotIndex);
    });

    let current = 0;
    let isAnimating = false;
    let isNudeMode = false;
    
    // Track watched characters
    let watchedCharacters = new Set();
    const REQUIRED_CHARACTERS = 7;
    
    // Update the watched characters counter
    function updateWatchedCounter() {
      const counterElement = document.querySelector('.top-right');
      counterElement.textContent = `Watched characters: ${watchedCharacters.size}`;
    }
    
    // Check if a character has been watched and update counter
    function markCharacterAsWatched(characterIndex) {
      if (!watchedCharacters.has(characterIndex)) {
        watchedCharacters.add(characterIndex);
        updateWatchedCounter();
      }
    }
    
    // Create popover for blocked nude button
    function createBlockedPopover() {
      // Check if popover already exists
      if (document.getElementById('blocked-popover')) return;
      
      const popover = document.createElement('div');
      popover.id = 'blocked-popover';
      popover.className = 'blocked-popover';
      
      const closeBtn = document.createElement('div');
      closeBtn.className = 'close-popover';
      closeBtn.textContent = '✕';
      closeBtn.addEventListener('click', function() {
        popover.classList.remove('active');
      });
      
      const message = document.createElement('div');
      message.className = 'blocked-message';
      message.textContent = 'You must watch at least 7 characters to unlock this';
      
      popover.appendChild(closeBtn);
      popover.appendChild(message);
      
      document.body.appendChild(popover);
      
      // Close popover when clicking outside
      document.addEventListener('click', function(e) {
        const popover = document.getElementById('blocked-popover');
        if (popover && popover.classList.contains('active') && 
            !popover.contains(e.target) && 
            e.target !== document.getElementById('send-nude-btn')) {
          popover.classList.remove('active');
        }
      });
      
      return popover;
    }
    
    // Show blocked popover
    function showBlockedPopover() {
      let popover = document.getElementById('blocked-popover');
      if (!popover) {
        popover = createBlockedPopover();
      }
      popover.classList.add('active');
    }

    function updateCarouselPositions() {
      // Đặt lại tất cả các thuộc tính hình ảnh
      for (let i = 0; i < images.length; i++) {
        const img = document.getElementById(`character-${i}`);
        img.className = 'character';
        img.style.opacity = 0;
        img.style.pointerEvents = 'none';
        img.style.zIndex = 0;
        img.style.display = 'block';
        img.style.transform = 'scale(0.5)';
        img.style.left = '50%';
        img.style.marginLeft = '-15%';
        img.style.transition = 'transform 0.8s cubic-bezier(0.77, 0, 0.175, 1), opacity 0.8s ease, left 0.8s ease';
      }
    
      // Check if we're on mobile
      const isMobile = window.innerWidth <= 768;
    
      // Hình ảnh chính
      const mainImg = document.getElementById(`character-${current}`);
      mainImg.className = 'character main';
      mainImg.style.opacity = 1;
      mainImg.style.pointerEvents = 'auto';
      mainImg.style.zIndex = 3;
      mainImg.style.transform = isMobile ? 'scale(1.35)' : 'scale(1.2)';
      mainImg.style.left = '50%';
      mainImg.style.marginLeft = isMobile ? '-30%' : '-15%';
    
      // Hình ảnh bên trái
      const prevIndex = (current - 1 + images.length) % images.length;
      const prevImg = document.getElementById(`character-${prevIndex}`);
      prevImg.className = 'character left';
      prevImg.style.opacity = 0.7;
      prevImg.style.pointerEvents = 'auto';
      prevImg.style.zIndex = 2;
      prevImg.style.transform = 'scale(0.84)';
      prevImg.style.left = '20%';
      prevImg.style.marginLeft = isMobile ? '-25%' : '-15%';
    
      // Hình ảnh bên phải
      const nextIndex = (current + 1) % images.length;
      const nextImg = document.getElementById(`character-${nextIndex}`);
      nextImg.className = 'character right';
      nextImg.style.opacity = 0.7;
      nextImg.style.pointerEvents = 'auto';
      nextImg.style.zIndex = 2;
      nextImg.style.transform = 'scale(0.84)';
      nextImg.style.left = '80%';
      nextImg.style.marginLeft = isMobile ? '-40%' : '-15%';
    
      // Ẩn tất cả các hình ảnh khác
      for (let i = 0; i < images.length; i++) {
        if (i !== current && i !== prevIndex && i !== nextIndex) {
          const img = document.getElementById(`character-${i}`);
          img.style.opacity = 0;
          img.style.pointerEvents = 'none';
          img.style.zIndex = 0;
        }
      }
    }

    function updateCharacterName() {
      const nameElement = document.getElementById('character_name');
      nameElement.classList.add('changing');
      
      setTimeout(() => {
        nameElement.textContent = characterNames[current];
        nameElement.classList.remove('changing');
      }, 400); // Half the transition time for a smooth crossfade effect
    }

    function nextCharacter() {
      if (isAnimating) return;
      isAnimating = true;
      
      // Thêm class animation-next cho tất cả các hình ảnh
      for (let i = 0; i < images.length; i++) {
        const img = document.getElementById(`character-${i}`);
        img.style.transition = 'transform 0.8s cubic-bezier(0.77, 0, 0.175, 1), opacity 0.8s ease, left 0.8s ease';
      }
      
      current = (current + 1) % images.length;
      updateCarouselPositions();
      updateCharacterName(); // Update character name
      
      // Mark the new current character as watched
      markCharacterAsWatched(current);
      
      setTimeout(() => {
        isAnimating = false;
      }, 800); // Đồng bộ với thời gian transition
    }

    function prevCharacter() {
      if (isAnimating) return;
      isAnimating = true;
      
      // Thêm class animation-prev cho tất cả các hình ảnh
      for (let i = 0; i < images.length; i++) {
        const img = document.getElementById(`character-${i}`);
        img.style.transition = 'transform 0.8s cubic-bezier(0.77, 0, 0.175, 1), opacity 0.8s ease, left 0.8s ease';
      }
      
      current = (current - 1 + images.length) % images.length;
      updateCarouselPositions();
      updateCharacterName(); // Update character name
      
      // Mark the new current character as watched
      markCharacterAsWatched(current);
      
      setTimeout(() => {
        isAnimating = false;
      }, 800); // Đồng bộ với thời gian transition
    }

    // Initialize character name when page loads
    function initCarousel() {
      const carousel = document.getElementById("carousel");
      carousel.innerHTML = '';
      
      // Create all image elements from the start
      for (let i = 0; i < images.length; i++) {
        const img = document.createElement('img');
        img.src = images[i];
        img.id = `character-${i}`;
        img.className = 'character';
        img.alt = `Character ${i+1}`;
        img.style.display = 'block';
        img.style.opacity = 0;
        carousel.appendChild(img);
      }
      
      // Update initial positions
      updateCarouselPositions();
      
      // Initialize character name
      document.getElementById('character_name').textContent = characterNames[current];
      
      // Initialize watched counter
      updateWatchedCounter();
    }

    // Khởi tạo carousel khi trang tải xong
    document.addEventListener('DOMContentLoaded', initCarousel);
    initCarousel();

    // Photo Mode functionality
    document.addEventListener('DOMContentLoaded', function() {
      const photoModeToggle = document.getElementById('photo-mode-toggle');
      const photoModePopover = document.getElementById('photo-mode-popover');
      const closePhotoPopover = document.getElementById('close-photo-popover');
      const photoModeOptions = document.querySelectorAll('.photo-mode-option');
      
      // Set default selection to OFF
      photoModeOptions[0].classList.add('selected');
      
      // Track photo mode state
      let photoModeActive = false;
      
      // Toggle popover
      photoModeToggle.addEventListener('click', function(e) {
        e.preventDefault();
        photoModePopover.classList.toggle('active');
      });
      
      // Close popover with X button
      closePhotoPopover.addEventListener('click', function() {
        photoModePopover.classList.remove('active');
      });
      
      // Function to update photo mode display
      function updatePhotoModeDisplay() {
        if (photoModeActive) {
          // Get current side characters
          const leftChar = document.querySelector('.character.left');
          const rightChar = document.querySelector('.character.right');
          
          // Hide side characters
          if (leftChar) leftChar.classList.add('photo-mode-hidden');
          if (rightChar) rightChar.classList.add('photo-mode-hidden');
          
          // Hide navigation buttons
          document.querySelectorAll('.nav-btn').forEach(btn => {
            btn.classList.add('photo-mode-hidden');
          });
          
          // Hide Send Nude button
          const sendNudeBtn = document.getElementById('send-nude-btn');
          if (sendNudeBtn) sendNudeBtn.classList.add('photo-mode-hidden');
          
          // Hide Watched characters counter
          const watchedCounter = document.querySelector('.top-right');
          if (watchedCounter) watchedCounter.classList.add('photo-mode-hidden');
        } else {
          // Show all characters
          document.querySelectorAll('.character').forEach(char => {
            char.classList.remove('photo-mode-hidden');
          });
          
          // Show navigation buttons
          document.querySelectorAll('.nav-btn').forEach(btn => {
            btn.classList.remove('photo-mode-hidden');
          });
          
          // Show Send Nude button
          const sendNudeBtn = document.getElementById('send-nude-btn');
          if (sendNudeBtn) sendNudeBtn.classList.remove('photo-mode-hidden');
          
          // Show Watched characters counter
          const watchedCounter = document.querySelector('.top-right');
          if (watchedCounter) watchedCounter.classList.remove('photo-mode-hidden');
        }
      }
      
      // Handle photo mode options
      photoModeOptions.forEach(option => {
        option.addEventListener('click', function() {
          // Remove selected class from all options
          photoModeOptions.forEach(opt => opt.classList.remove('selected'));
          
          // Add selected class to clicked option
          this.classList.add('selected');
          
          // Apply photo mode based on selection
          photoModeActive = this.dataset.mode === 'on';
          
          // Update display
          updatePhotoModeDisplay();
          
          // Apply flashing effect to the Photo Mode link when active
          if (photoModeActive) {
            photoModeToggle.classList.add('flashing-text');
          } else {
            photoModeToggle.classList.remove('flashing-text');
          }
          
          // Close the popover after selection
          photoModePopover.classList.remove('active');
        });
      });
      
      // Close popover when clicking outside
      document.addEventListener('click', function(e) {
        if (!photoModePopover.contains(e.target) && e.target !== photoModeToggle) {
          photoModePopover.classList.remove('active');
        }
      });
      
      // Hook into carousel navigation to update photo mode display after character changes
      const originalNextCharacter = window.nextCharacter;
      window.nextCharacter = function() {
        originalNextCharacter();
        // Wait for the animation to complete
        setTimeout(() => {
          if (photoModeActive) updatePhotoModeDisplay();
        }, 800);
      };
      
      const originalPrevCharacter = window.prevCharacter;
      window.prevCharacter = function() {
        originalPrevCharacter();
        // Wait for the animation to complete
        setTimeout(() => {
          if (photoModeActive) updatePhotoModeDisplay();
        }, 800);
      };
    });

    // About popover functionality
    document.addEventListener('DOMContentLoaded', function() {
      const aboutToggle = document.getElementById('about-toggle');
      const aboutPopover = document.getElementById('about-popover');
      const closeAboutPopover = document.getElementById('close-about-popover');
      
      // Toggle popover
      aboutToggle.addEventListener('click', function(e) {
        e.preventDefault();
        aboutPopover.classList.toggle('active');
      });
      
      // Close popover with X button
      closeAboutPopover.addEventListener('click', function() {
        aboutPopover.classList.remove('active');
      });
      
      // Close popover when clicking outside
      document.addEventListener('click', function(e) {
        if (!aboutPopover.contains(e.target) && e.target !== aboutToggle) {
          aboutPopover.classList.remove('active');
        }
      });
    });


    // Theme color functionality
    document.addEventListener('DOMContentLoaded', function() {
      const themeToggle = document.getElementById('theme-toggle');
      const themePopover = document.getElementById('theme-popover');
      const closePopover = document.getElementById('close-popover');
      const miniBg = document.querySelector('.mini-bg');
      
      // Color options
      const colors = [
        '#000000', '#1C1C1C', '#001F3F', '#2C003E', '#013220', '#2E1A12', '#4B0000', '#ea6d1e'
      ];
      
      // Create color options
      colors.forEach((color, index) => {
        const colorOption = document.createElement('div');
        colorOption.className = 'color-option';
        colorOption.style.backgroundColor = color;
        colorOption.dataset.color = color;
        themePopover.appendChild(colorOption);
        
        // Add click event to change theme
        colorOption.addEventListener('click', function() {
          miniBg.style.transition = 'background-color 0.3s ease';
          miniBg.style.backgroundColor = color;
        });
      });
      
      // Toggle popover
      themeToggle.addEventListener('click', function(e) {
        e.preventDefault();
        themePopover.classList.toggle('active');
        
        if (themePopover.classList.contains('active')) {
          // Animate color options appearing one after another
          const colorOptions = document.querySelectorAll('.color-option');
          colorOptions.forEach((option, index) => {
            setTimeout(() => {
              option.classList.add('animate');
            }, index * 50);
          });
        } else {
          resetColorOptionsAnimation();
        }
      });
      
      // Close popover with X button
      closePopover.addEventListener('click', function() {
        themePopover.classList.remove('active');
        resetColorOptionsAnimation();
      });
      
      // Close popover when clicking outside
      document.addEventListener('click', function(e) {
        if (!themePopover.contains(e.target) && e.target !== themeToggle) {
          themePopover.classList.remove('active');
          resetColorOptionsAnimation();
        }
      });
      
      // Reset animation state of color options
      function resetColorOptionsAnimation() {
        const colorOptions = document.querySelectorAll('.color-option');
        colorOptions.forEach(option => {
          option.classList.remove('animate');
        });
      }
    });
    // Add this after the initCarousel function
    window.addEventListener('resize', function() {
      updateCarouselPositions();
    });
    // Add event listener for the Send Nude button
    document.addEventListener('DOMContentLoaded', function() {
      const sendNudeBtn = document.getElementById('send-nude-btn');
      if (sendNudeBtn) {
        sendNudeBtn.addEventListener('click', function() {
          if (watchedCharacters.size >= REQUIRED_CHARACTERS) {
            toggleNudeMode();
          } else {
            showBlockedPopover();
          }
        });
      }
      
      // Initialize the counter
      updateWatchedCounter();
      
      // Mark the initial character as watched
      markCharacterAsWatched(current);
    });

    function toggleNudeMode() {
      if (isAnimating) return;
      isAnimating = true;
      
      // Get the current main character image
      const mainImg = document.getElementById(`character-${current}`);
      
      // Toggle nude mode for the current character only
      isNudeMode = !isNudeMode;
      
      if (isNudeMode) {
        // Start flip-in animation
        mainImg.classList.add('flipping', 'flip-in');
        
        // Change the image source at the middle of the animation (when card is perpendicular to screen)
        setTimeout(() => {
          mainImg.src = nudeImages[current];
        }, 400); // Half of the animation duration
        
        // Remove animation classes when complete
        setTimeout(() => {
          mainImg.classList.remove('flipping', 'flip-in');
          isAnimating = false;
        }, 800); // Full animation duration
      } else {
        // Start flip-out animation
        mainImg.classList.add('flipping', 'flip-out');
        
        // Change the image source at the middle of the animation
        setTimeout(() => {
          mainImg.src = images[current];
        }, 400); // Half of the animation duration
        
        // Remove animation classes when complete
        setTimeout(() => {
          mainImg.classList.remove('flipping', 'flip-out');
          isAnimating = false;
        }, 800); // Full animation duration
      }
    }

    // Modify the nextCharacter and prevCharacter functions to reset nude mode
    const originalNextCharacter = nextCharacter;
    window.nextCharacter = function() {
      // Reset to normal image if in nude mode
      if (isNudeMode) {
        const mainImg = document.getElementById(`character-${current}`);
        mainImg.classList.remove('flipping', 'flip-in', 'flip-out');
        mainImg.src = images[current];
        isNudeMode = false;
      }
      originalNextCharacter();
    };

    const originalPrevCharacter = prevCharacter;
    window.prevCharacter = function() {
      // Reset to normal image if in nude mode
      if (isNudeMode) {
        const mainImg = document.getElementById(`character-${current}`);
        mainImg.classList.remove('flipping', 'flip-in', 'flip-out');
        mainImg.src = images[current];
        isNudeMode = false;
      }
      originalPrevCharacter();
    };

  </script>
</body>
</html>


